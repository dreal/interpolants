\section{Preliminaries}
\label{sec:prelim}

\paragraph{Craig interpolation~\cite{MR0104564}.}
We consider Craig interplants for quantifier-free first-order formulas. Given two formulas $A$ and $B$, such that $A ∧ B$ is unsatisfiable, an interpolant $I$ is a formula satisfying:
\begin{itemize}
\item $A ⇒ I$;
\item $B ∧ I ⇒ ⊥$;
\item $fv(I) ⊆ fv(A) ∩ fv(B)$ where $fv$ returns the free variables in a formula.
\end{itemize}

\paragraph{Nonlinear first-order theories over the reals.} 

We consider first-order formulas interpreted over the real numbers. Our special focus is formulas that can contain arbitrary nonlinear functions that are {\em Type 2 computable}~\cite{CAbook,vasco}. Intuitively, Type 2 computability corresponds to {\em numerical computability}. For our purpose, it is enough to note that this set of functions consist of all common elementary functions, as well as solutions of Lipschitz-continuous ordinary differential equations. Thus the first-order language is extremely expressive... 

\paragraph{Interval constraint propagation.}

Interval Constraint Propagation (ICP)~\cite{handbookICP} finds
solutions of real constraints using the ``branch-and-prune'' method, combining
interval arithmetic and constraint propagation. The idea is to use interval
extensions of functions to ``prune'' out sets of points that are not in the
solution set and ``branch'' on intervals when
such pruning can not be done, recursively until a small enough box
that may contain a solution is found or inconsistency is observed. A high-level description of the decision version of ICP is given in Algorithm~\ref{icpalgo}~\cite{handbookICP,DBLP:conf/cade/GaoAC12}.
\begin{algorithm}\label{algo1}
\caption{ICP($f_1,...,f_m, B_0 = I_1^0\times\cdots\times I_n^0, \delta$)}\label{icpalgo}
\begin{algorithmic}[1]
\Statex
    \State $S \gets B_0$
    \While{$S \neq \emptyset$}
        \State $B \gets S.\mathrm{pop}()$
        \While{$\exists 1 \leq i \leq m, B \neq_{\delta} \mathrm{Prune}(B,f_i)$}
        \State $B \gets \mathrm{Prune}(B, f_i)$
        \EndWhile
        \If{$B\neq \emptyset$}
            \If{$\exists 1\leq i\leq m, |\sharp f_i(B)|\geq \delta$}
                \State $\{B_1,B_2\} \gets \mathrm{Branch}(B, i)$
                \State $S.\mathrm{push}(\{B_1,B_2\})$
            \Else
                \State \Return {\sf sat}
            \EndIf
        \EndIf
    \EndWhile
    \State \Return {\sf unsat}
\end{algorithmic}
\end{algorithm}





\paragraph{Proofs from constraint propagation.}

The complete theory behind proof extraction from $\delta$-decision procedure is available in~\cite{DBLP:conf/synasc/GaoKC14}.
Here, we described a simplified version.
The proof is divides the solution space until it can prove, using interval arithmetic, that each small piece of the solution space is empty.
The solver uses constraints propagation and pruning steps to limit the amount of branching required.
However, the proof it produces only need to consider two main rules: splitting and theory lemma.
The \textsc{Split} rules divides the solution space into two disjoint subspaces.
The theory lemmas (\textsc{ThLem}) are the leaves of the proof.
They occurs when the solver managed to prove the absence of solution in a given subspace.
The interval constraints propagation algorithms works on one constraint at the time. 
The \textsc{Weakening} rules extract those conjunct out of the main formula.

Each step of the proof has a set of variables $\vec x$ with a domain $\vec D$ and $F$ is a formula.
We use of vectors in the formulas, writing $\vec x ∈ \vec D$ to denote $\bigwedge_i x_i ∈ D_i$.
The domains are intervals, i.e., each $D_i$ has the form $[l_i,u_i]$ where $l_i$,$u_i$ are the lower and upper bounds for $x_i$.
Since we are looking at unsatisfiability proofs, each node implies $⊥$.

The root of the proof is has formula $A ∧ B$ and $D$ covers the entire domain,
the inner nodes are \textsc{Split}s,
and the proof's leaves are theory lemmas directly followed by a weakening.

\begin{notation}
Conjunction binds stronger. Intervals assume well-definedness. 
\end{notation}

\begin{mathpar}
\inferrule{ {} }{
  \vec x ∈ \vec D ∧ c \entails ⊥
}{(\thLem)}\\

\inferrule{
  C := c ∧ \bigwedge_k C_k \\
  \vec x ∈ \vec D ∧ c \entails ⊥
}{
  \vec x ∈ \vec D ∧ C \entails ⊥
}{(\weaken)}\\

\inferrule{
  x_i ∈ [l_i, p] ∧ \bigwedge_{j ≠ i} x_j ∈ D_j ∧ C \entails ⊥ \\
  x_i ∈ [p, u_i] ∧ \bigwedge_{j ≠ i} x_j ∈ D_j ∧ C \entails ⊥
}{
  x_i\in [l_i, u_i] \wedge \bigwedge_{j\neq i} x_j∈\vec D_j ∧ C \entails ⊥
}{(\splt)}
\end{mathpar}

\todo[inline]{in the intro we speak only of contraction, we should explain how they are turned into splits and thLem}
