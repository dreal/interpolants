\section{Introduction}
\label{sec:intro}

%Software often interact with the physical world. Plant controllers, robots, cars, etc., all theses systems contains sensors and actuators. Validating such systems requires requires method to reason not only about the software part, but also the environment, usually described by continuous equations.

Verification problems of complex embedded software can be reduced to solving logic formulas that contain continuous, typically nonlinear, real functions. The framework of δ-decision procedures~\cite{DBLP:conf/lics/GaoAC12,DBLP:conf/fmcad/GaoKC13} establishes that, under reasonable relaxations, nonlinear SMT formulas over the reals are in principle as solvable as SAT problems. Indeed, using solvers for nonlinear theories as the algorithmic engines, straightforward bounded model checking has already shown promise on nonlinear hybrid systems~\cite{DBLP:conf/cav/ChenAS13,DBLP:conf/tacas/KongGCC15}. Naturally, for enhancing performance, more advanced reasoning techniques need to be introduced, extending SMT towards general quantifier elimination. However, it is well-known that quantifier elimination is not feasible for nonlinear theories over the reals. The complexity of quantifier elimination for real arithmetic (i.e., polynomials only) has a double-exponential lower bound, which is too high for most applications; when transcendental functions are further involved, the problem becomes highly undecidable.

Craig interpolation provides a weak form of quantifier elimination.
Given two formulas $A$ and $B$, such that $A ∧ B$ is unsatisfiable, an interpolant $I$ is a formula satisfying: (1) $A ⇒ I$, (2) $B ∧ I ⇒ ⊥$, and (3) $I$ contains only variables common to $A$ and $B$.
It has found many applications in verifications:
as an heuristic to compute inductive invariant~\cite{DBLP:conf/cav/McMillan03,DBLP:conf/vmcai/McMillan07,DBLP:conf/sas/McMillan11},
for predicate discovery in abstraction refinement loops~\cite{DBLP:conf/cav/McMillan06},
inter procedural analysis~\cite{DBLP:conf/vmcai/AlbarghouthiGC12,DBLP:conf/cav/AlbarghouthiLGC12},
shape analysis~\cite{DBLP:conf/esop/AlbarghouthiBCK15},
fault-localisation~\cite{DBLP:conf/fm/ErmisSW12,DBLP:conf/vmcai/ChristESW13,DBLP:conf/sigsoft/SchafSW13}, and so on.

In this paper, we present methods for computing Craig interpolants in expressive nonlinear theories over the reals. To do so, we extract interpolants from proofs of unsatisfiability generated by δ-decision procedures~\cite{DBLP:conf/synasc/GaoKC14} that are based on Interval Constraint Propagation (ICP)~\cite{handbookICP}. The proposed algorithms are guaranteed to find the interpolants between two formulas $A$ and $B$, whenever $A ∧ B$ is not δ-satisfiable.

The framework of δ-decision procedures formulates a relaxed notion of logical decisions, by allowing one-sided δ-bounded errors~\cite{DBLP:conf/lics/GaoAC12,DBLP:conf/cade/GaoAC12}. Instead of asking whether a formula has a satisfiable assignment or not, we ask if it is ``{\em δ-satisfiable}" or ``unsatisfiable". Here, a formula is δ-satisfiable if it would be satisfiable under some {\em δ-perturbation} on the original formula~\cite{DBLP:conf/cade/GaoAC12}. On the other hand, when the algorithm determines that the formula is ``unsatisfiable", it is a definite answer and no numerical error can be involved. Indeed, we can extract proofs of unsatisfiability from such answers, even though the search algorithms themselves involve numerical errors~\cite{DBLP:conf/synasc/GaoKC14}. This is accomplished by analyzing the execution trace of the search tree based on the ICP algorithm. 


The core ICP algorithm uses a {\em branch-and-prune} loop that aims to either find a small enough box that witnesses δ-satisfiability, or detect that no solution exists. The loop consists of two main steps:
\begin{itemize}
\item (Prune) Use interval arithmetic to maintain overapproximations of the solution sets, so that one can ``prune" out the part of the state space that does not contain solutions.
\item (Branch) When the pruning operation does not make progress, one performs a depth-first search by ``branching" on variables and restart pruning operations on a subset of the domain. 
\end{itemize}
The loop is continued until either a small enough box that may contain a solution is found, or any conflict among the constraints is observed.

\begin{figure}
\centering
\includegraphics[scale=0.042]{img/example.pdf}
\caption{
    Interval constraint propagation and interpolant construction where $A$ is $y≥x²$ and $B$ is $y ≤ -\cos(x) + 0.8$ over the domain $x∈[-1,1]$, $y∈[-1,1]$.
    The $A$ is shown in green and $B$ in red.
    The final interpolant is the green part.
}
\label{fig:example}
\end{figure}


When a formula is unsatisfiable, the execution trace of the algorithm generates a (potentially large) proof tree that divides the space into small hypercubes and associating a constraint to each hypercube~\cite{DBLP:conf/synasc/GaoKC14}. The interpolation algorithm can essentially traverse this proof tree to construct the interpolant. To each leaf in the proof, we associate ⊤ or ⊥ depending on the source of the contradiction. The inner nodes of the proof tree correspond to case splits and are handled in a manner reminiscent of Pudl{\'a}k's algorithm~\cite{MR1472134}. Common variables are kept as branching points and $A$,$B$ local variables are eliminated. A simple example of the method is as follows:

\begin{example}
Let $A: y≥x²$ and $B: y ≤ -\cos(x) + 0.8$ be two constraints over the domain $x∈[-1,1]$, $y∈[-1,1]$.
A δ-decision procedure uses $A$ and $B$ to contract the domains of $x$ and $y$ by removing the parts that be shown empty using interval arithmetic.
Figure~\ref{fig:example} shows a sequence of contraction proving the unsatisfiability of the formula.
As the contraction occurs, we color the region of the space by the color of the \emph{opposite} formula.
When the interval constraint propagation has finished, the initial domain is associated to either $A$ or $B$.
The interpolant $I$ is composed of the parts corresponding to $A$. We will compute that $I$ is $y ≥ 0 ∧ (0.26 ≤ y ∨ (y ≤ 0.26 ∧ -0.51 ≤ x ≤ 0.51))$.
\end{example}

We have implemented the algorithms in the SMT solver \dReal~\cite{DBLP:conf/cade/GaoKC13}. We show examples of applications from various domains such as control and robotic design, and hybrid system verification.  

\paragraph{Special Note.} After the first publication of this work, we found that Kupferschmid and Becker have published a similar result~\cite{DBLP:conf/formats/KupferschmidB11}. They presented an interpolation algorithm based on McMillan's propositional interpolation system. Our algorithm is based on the Pudl{\'a}k interpolation system~\cite{MR1472134}, which is slightly different but the main idea is the same. The focus of~\cite{DBLP:conf/formats/KupferschmidB11} is on non-ODE constraints, while most of the examples in this paper come from hybrid system design and involve ODE constraints.   

\paragraph{Related work.}
Craig interpolation for real or integer arithmetic has focused on the linear fragment with LA(ℝ)~\cite{DBLP:conf/tacas/McMillan04,DBLP:conf/vmcai/RybalchenkoS07} and LA(ℤ)~\cite{DBLP:conf/cade/BrilloutKRW10,DBLP:conf/tacas/GriggioLS11}, with the exception of \iSat~\cite{DBLP:journals/jsat/FranzleHTRS07} as mentioned in the special note above. 
Dai et al.~\cite{DBLP:conf/cav/DaiXZ13} present a method to generate interpolants for polynomial formula.
Their method use semi-definite programming to search for a polynomial interpolant and it is complete under the \emph{Archimedean} condition. In fact, the Archimedean condition imposes similar restrictions as δ-decidability, e.g., the variables over bounded domains and limited support for strict inequalities.
Our method is more general in that it handles nonlinear fragments over ℝ that include transcendental functions and solution functions of ordinary differention equations.
Many existing tools can compute interpolants for in the theory of linear real arithmetic, such as 
\mathsat~\cite{mathsat5},
\princess~\cite{DBLP:conf/cade/BrilloutKRW10},
\smtinterpol~\cite{DBLP:conf/spin/ChristHN12}, and
\zthree~\cite{DBLP:conf/fmcad/McMillan11}.

\paragraph{Outline.}
In Section~\ref{sec:prelim}, we review notions related to interpolation, nonlinear arithmetic over the Reals and δ-decision procedures.
In Section~\ref{sec:itp}, we introduce our interpolation algorithm.
In Section~\ref{sec:eval}, we present and evaluate our implementation.
We conclude and sketch future research direction in Section~\ref{sec:concl}.

%Given two formulas which conjunction is unsatisfiable, the Craig interpolant~\cite{MR0104564} is a formula over the common variables that serves

%reasoning about the combined system of software and the physical environment. Modeling such environment typically requires extensive use of continuous functions over real numbers, such as solution functions of nonlinear differential equations. Thus solving logic formulas in nonlinear theories over the real numbers is a basic requirement for verification. 
%Unfortunately, automated reasoning for about nonlinear systems of equations is a hard, even undecidable in the general case~\cite{DBLP:conf/lics/GaoAC12}.
%However, recently the point of view~\cite{realQuasiDec,hybridQuasiDec} where reals are considered up to a certain precision was used to show decidability of the satisfiability for non-linear real arithmetic
%The intuition is that well engineered systems are robust, thus, are able to deal with small perturbations.

%In the δ-satisfiability framework, a system of equations is unsatisfiable if it does not have solution even when perturbed up to a δ constant. The complexity of δ-satisfiability is NP without ODE~\cite{DBLP:conf/lics/GaoAC12} and PSpace with ODE~\cite{DBLP:conf/fmcad/GaoKC13}. Furthermore, δ-satisfiability can leverage on the finite precision arithmetic for efficient implementations.
