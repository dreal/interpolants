\section{Introduction}
\label{sec:intro}

%Software often interact with the physical world. Plant controllers, robots, cars, etc., all theses systems contains sensors and actuators. Validating such systems requires requires method to reason not only about the software part, but also the environment, usually described by continuous equations.

Verification problems of complex embedded software can be reduced to solving logic formulas that contain continuous, typically nonlinear, real functions. The framework of δ-decision procedures~\cite{DBLP:conf/lics/GaoAC12,DBLP:conf/fmcad/GaoKC13} establishes that, under reasonable relaxations, nonlinear SMT formulas over the reals are in principle as solvable as SAT problems. Indeed, using solvers for nonlinear theories as the algorithmic engines, straightforward bounded model checking has already shown promise on nonlinear hybrid systems~\cite{DBLP:conf/cav/ChenAS13,DBLP:conf/tacas/KongGCC15}. Naturally, for enhancing performance, more advanced reasoning techniques need to be introduced, extending SMT towards general quantifier elimination. However, it is well-known that quantifier elimination is not feasible for nonlinear theories over the reals\footnote{Quantifier elimination for real arithmetic (i.e., with polynomials only) is computable but the complexity is too high for most practical applications. If transcendental functions are involved, the problem is highly undecidable.}.  

Craig interpolation is a weak form of quantifier elimination.
Given two formulas $A$ and $B$, such that $A ∧ B$ is unsatisfiable, an interpolant $I$ is a formula satisfying: (1) $A ⇒ I$, (2) $B ∧ I ⇒ ⊥$, and (3) $I$ contains only variables common to $A$ and $B$.
It has found many applications in verifications:
as an heuristic to compute inductive invariant~\cite{DBLP:conf/cav/McMillan03,DBLP:conf/vmcai/McMillan07,DBLP:conf/sas/McMillan11},
for predicate discovery in abstraction refinement loops~\cite{DBLP:conf/cav/McMillan06},
inter procedural analysis~\cite{DBLP:conf/vmcai/AlbarghouthiGC12,DBLP:conf/cav/AlbarghouthiLGC12},
shape analysis~\cite{DBLP:conf/esop/AlbarghouthiBCK15},
fault-localisation~\cite{DBLP:conf/fm/ErmisSW12,DBLP:conf/vmcai/ChristESW13,DBLP:conf/sigsoft/SchafSW13}, and so on.

In this paper, we present methods for computing Craig interpolants in expressive nonlinear theories over the reals. To do so, we extract interpolants from proofs of unsatisfiability generated by δ-decision procedures~\cite{DBLP:conf/synasc/GaoKC14} based on Interval Constraint Propagation (ICP)~\cite{handbookICP}. The proposed algorithms are guaranteed to find the interpolants between two formulas $A$ and $B$ whenever $A ∧ B$ is not δ-satisfiable.

δ-decision problems relax the standard notion of logical decisions by allowing one-sided δ-bounded errors~\cite{DBLP:conf/lics/GaoAC12,DBLP:conf/cade/GaoAC12}. Instead of asking whether a formula has a satisfiable assignment or not, we ask if it is ``{\em δ-satisfiable}" or ``unsatisfiable". Here, a formula is δ-satisfiable if it would be satisfiable under some {\em δ-perturbation} on the original formula~\cite{DBLP:conf/cade/GaoAC12}. On the other hand, when the algorithm determines that the formula is ``unsatisfiable", no numerical error can be involved. Indeed, we can extract proofs of unsatisfiability from such answers, even though the search algorithms involve numerical errors~\cite{DBLP:conf/synasc/GaoKC14}. This is accomplished by analyzing the execution trace of the search tree based on the ICP algorithm. 


The core ICP algorithm uses a {\em branch-and-prune} loop that aims to either find a small enough box that witnesses δ-satisfiability, or detect that no δ-solutions exists. The loop consists of two main steps:
\begin{itemize}
\item (Prune) Use interval arithmetic to maintain overapproximations of the solution sets, so that one can ``prune" out the part of the state space that does not contain solutions.
\item (Branch) When the pruning operation does not make progress, one performs a depth-first search by ``branching" on variables and restart pruning operations on a subset of the domain. 
\end{itemize}
The loop is continued until either a small enough box that may contain a solution is found, or any conflict among the constraints is observed.

\begin{figure}
\centering
\includegraphics[scale=0.04]{img/example.pdf}
\caption{
    Interval constraint propagation and interpolant construction where $A$ is $y≥x²$ and $B$ is $y ≤ -\cos(x) + 0.8$ over the domain $x∈[-1,1]$, $y∈[-1,1]$.
    The $A$ is shown in green and $B$ in red.
    The final interpolant is the green part.
}
\label{fig:example}
\end{figure}


When a formula is unsatisfiable, the execution trace of the algorithm becomes can be seen as a proof tree that divides the space into small hypercubes and associating a constraint to each hypercube~\cite{DBLP:conf/synasc/GaoKC14}. Consequently, the interpolation algorithm can traverse this proof tree to construct the interpolant. To each leaf in the proof, we associate ⊤ or ⊥ depending on the source of the contradiction. The inner nodes of the proof tree correspond to case splits and are handled in a manner reminiscent of Pudl{\'a}k's algorithm~\cite{MR1472134}. Common variables are kept as branching points and $A$,$B$ local variables are eliminated. A simple example of the method is as follows:

\begin{example}
Let $A$ be $y≥x²$ and $B$ by $y ≤ -\cos(x) + 0.8$ over the domain $x∈[-1,1]$, $y∈[-1,1]$.
A δ-decision procedure uses $A$ and $B$ to contract the domains of $x$ and $y$ by removing the parts that be shown empty using interval arithmetic.
Figure~\ref{fig:example} shows a sequence of contraction proving the unsatisfiability of the formula.
As the contraction occurs, we color the region of the space by the color of the \emph{opposite} formula.
When the interval constraint propagation has finished the initial domain is associated to either $A$ or $B$.
The interpolant $I$ is composed of the parts corresponding to $A$.
$I$ is $y ≥ 0 ∧ (0.26 ≤ y ∨ (y ≤ 0.26 ∧ -0.51 ≤ x ≤ 0.51))$.
\end{example}

We have implemented the algorithms in the SMT solver \dReal~\cite{DBLP:conf/cade/GaoKC13}. We show examples of applications from various domains such as control and robotic design, and hybrid system verification.  

\paragraph{Related work.}
Our algorithm is surprisingly similar to the algorithm for propositional interpolation studied by Pudl{\'a}k~\cite{MR1472134}.
However, it applies to a different theory.
Craig interpolation for real or integer arithmetic has focused on the linear fragment with LA(ℝ)~\cite{DBLP:conf/tacas/McMillan04,DBLP:conf/vmcai/RybalchenkoS07} and LA(ℤ)~\cite{DBLP:conf/cade/BrilloutKRW10,DBLP:conf/tacas/GriggioLS11}.
Our method currently handles nonlinear fragments over ℝ.

Existing tools to compute interpolation such as
\mathsat~\cite{mathsat5},
\princess~\cite{DBLP:conf/cade/BrilloutKRW10},
\smtinterpol~\cite{DBLP:conf/spin/ChristHN12}, and
\zthree~\cite{DBLP:conf/fmcad/McMillan11}
focus on linear arithmetic.
We are the first to provide interpolation in nonlinear theories.


\paragraph{Outline.}
In Section~\ref{sec:prelim}, we review notions related to interpolation, nonlinear arithmetic over the Reals and δ-decision procedures.
In Section~\ref{sec:itp}, we introduce our interpolation algorithm.
In Section~\ref{sec:eval}, we present and evaluate our implementation.
Finally, we conclude and sketch future research direction in Section~\ref{sec:concl}.

%Given two formulas which conjunction is unsatisfiable, the Craig interpolant~\cite{MR0104564} is a formula over the common variables that serves

%reasoning about the combined system of software and the physical environment. Modeling such environment typically requires extensive use of continuous functions over real numbers, such as solution functions of nonlinear differential equations. Thus solving logic formulas in nonlinear theories over the real numbers is a basic requirement for verification. 
%Unfortunately, automated reasoning for about nonlinear systems of equations is a hard, even undecidable in the general case~\cite{DBLP:conf/lics/GaoAC12}.
%However, recently the point of view~\cite{realQuasiDec,hybridQuasiDec} where reals are considered up to a certain precision was used to show decidability of the satisfiability for non-linear real arithmetic
%The intuition is that well engineered systems are robust, thus, are able to deal with small perturbations.

%In the δ-satisfiability framework, a system of equations is unsatisfiable if it does not have solution even when perturbed up to a δ constant. The complexity of δ-satisfiability is NP without ODE~\cite{DBLP:conf/lics/GaoAC12} and PSpace with ODE~\cite{DBLP:conf/fmcad/GaoKC13}. Furthermore, δ-satisfiability can leverage on the finite precision arithmetic for efficient implementations.
